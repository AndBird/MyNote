1、基础数据类型
int a = 3;
int b = a;
Log.e("a =", "a=" + a);
Log.e("b =", "b=" + b);
Log.e("a =b", "a=b" + (a== b));
b = 4;
Log.e("a =", "a=" + a);
Log.e("b =", "b=" + b);
Log.e("a =b", "a=b" + (a== b));

输出结果:
08-06 15:18:59.886: E/a =(3823): a=3
08-06 15:18:59.886: E/b =(3823): b=3
08-06 15:18:59.886: E/a =b(3823): a=btrue
08-06 15:18:59.886: E/a =(3823): a=3
08-06 15:18:59.886: E/b =(3823): b=4
08-06 15:18:59.886: E/a =b(3823): a=bfalse


String 类型：
String a = "3";
String b = "3";
Log.e("a =", "a=" + a);
Log.e("b =", "b=" + b);
Log.e("a =b", "a=b" + (a== b));

b = a + 1;
Log.e("a =", "a=" + a);
Log.e("b =", "b=" + b);
Log.e("a =b", "a=b" + (a== b));

String a = new String("3");
String b = new String("3");
Log.e("a =", "a=" + a);
Log.e("b =", "b=" + b);
Log.e("a =b", "a=b" + (a== b));

输出结果:
08-06 15:20:50.426: E/a =(4119): a=3
08-06 15:20:50.426: E/b =(4119): b=3
08-06 15:20:50.426: E/a =b(4119): a=btrue //赋值

08-06 15:20:50.426: E/a =(4119): a=3
08-06 15:20:50.426: E/b =(4119): b=31
08-06 15:20:50.426: E/a =b(4119): a=bfalse

08-06 15:22:18.736: E/a =(4463): a=3
08-06 15:22:18.736: E/b =(4463): b=3
08-06 15:22:18.736: E/a =b(4463): a=bfalse //new
 
引用类对象:
public class Bean {
	public int a;
	public int b;
	
	public Bean(int a, int b) {
		this.a = a;
		this.b = b;
	}

}

private void change(final Bean c){
	c.a = 5;
	c.b = 6;
	Log.e("c =", "c=" + c.a + "," + c.b);
}

Bean a = new Bean(1, 1);
Bean b = a;
Log.e("a =", "a=" + a.a + "," + a.b);
Log.e("b =", "b=" + b.a + "," + b.b);
Log.e("a =b", "a=b" + (a== b));

b = new Bean(1, 1);
Log.e("a =", "a=" + a.a + "," + a.b);
Log.e("b =", "b=" + b.a + "," + b.b);
Log.e("a =b", "a=b" + (a== b));

//成员修改
b = a;
b.a = 3;
b.b = 4;
Log.e("a =", "a=" + a.a + "," + a.b);
Log.e("b =", "b=" + b.a + "," + b.b);
Log.e("a =b", "a=b" + (a== b));

change(a);
Log.e("a =", "a=" + a.a + "," + a.b);
Log.e("b =", "b=" + b.a + "," + b.b);
Log.e("a =b", "a=b" + (a== b));

final Bean c = a;
c.a = 5;
c.b = 6;
Log.e("a =", "a=" + a.a + "," + a.b);
Log.e("b =", "b=" + b.a + "," + b.b);
Log.e("c =", "c=" + c.a + "," + c.b);
Log.e("a =b", "a=b" + (a== b));
Log.e("a =c", "a=c" + (a== c));


输出结果:
08-06 15:25:02.206: E/a =(4807): a=1,1
08-06 15:25:02.206: E/b =(4807): b=1,1
08-06 15:25:02.206: E/a =b(4807): a=btrue //赋值

08-06 15:25:02.206: E/a =(4807): a=1,1
08-06 15:25:02.206: E/b =(4807): b=1,1
08-06 15:25:02.206: E/a =b(4807): a=bfalse //new

08-06 15:25:02.206: E/a =(4807): a=3,4
08-06 15:25:02.206: E/b =(4807): b=3,4
08-06 15:25:02.206: E/a =b(4807): a=btrue

08-06 15:25:02.206: E/c =(4807): c=5,6
08-06 15:25:02.206: E/a =(4807): a=5,6
08-06 15:25:02.206: E/b =(4807): b=5,6
08-06 15:25:02.206: E/a =b(4807): a=btrue

08-06 15:25:02.206: E/a =(4807): a=5,6
08-06 15:25:02.206: E/b =(4807): b=5,6
08-06 15:25:02.206: E/c =(4807): c=5,6
08-06 15:25:02.206: E/a =b(4807): a=btrue
08-06 15:25:02.206: E/a =c(4807): a=ctrue


1、基本数据类型和对象的引用都是值传递，区别在于:
基本数据类型的变量数据存放在栈内存中，而引用的对象（变量存在栈内存）的值
存放在堆内存或常量池中（字符串常量对象存放在常量池中），值传递时都是栈内存，
基本数据类型是数据的copy，引用对象的值传递是传递堆内存的地址引用。

2、栈内存中存放基本数据类型的变量数据和对象的引用，对象本身存放在堆（new 出来的对象）或者常量池中（字符串常量对象存放在常量池中）
3、final只对引用的"值"(即内存地址)有效，它迫使引用只能指向初始指向的那个对象，改变它的指向会导致编译期错误。至于它所指向的对象 的变化，final是不负责的
final StringBuffer a = new StringBuffer("111");
final StringBuffer b = new StringBuffer("222");
a=b;//此句编译不通过
final StringBuffer a = new StringBuffer("111");
a.append("222");//编译通过

